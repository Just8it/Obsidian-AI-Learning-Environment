/*
 * AI LEARNING ASSISTANT PLUGIN
 * Generated by Antigravity
 * Features: Flashcard Generation + Summary Generation
 */

const { Plugin, PluginSettingTab, Setting, Notice, requestUrl, Modal, setIcon } = require("obsidian");

// Default prompts for each level (Flashcards)
const DEFAULT_FLASHCARD_PROMPTS = {
    "1": { purpose: "Summarize the text into key definitions.", detail: "Focus ONLY on core concepts. Ignore sub-points." },
    "2": { purpose: "Cover main concepts and key facts.", detail: "Capture major headings and vital supporting facts." },
    "3": { purpose: "Create a standard study deck.", detail: "Standard coverage. Capture main ideas, key details, and important lists." },
    "4": { purpose: "Create a detailed study deck.", detail: "High Detail. Capture concepts, formulas, lists, and specific nuances." },
    "5": { purpose: "EXHAUSTIVE EXAM PREPARATION.", detail: "ATOMIZE EVERYTHING. Extract EVERY SINGLE FACT. If a paragraph has 3 points, make 3 cards. Precision > Quantity." }
};

// Default prompts for each level (Summaries)
const DEFAULT_SUMMARY_PROMPTS = {
    "1": { purpose: "Create a brief executive summary.", detail: "Maximum 3-5 bullet points. Only the most critical takeaways." },
    "2": { purpose: "Create a concise overview.", detail: "Cover main sections with 1-2 sentences each. Include key terms." },
    "3": { purpose: "Create a balanced study summary.", detail: "Cover all major topics. Include definitions, key points, and important relationships." },
    "4": { purpose: "Create a comprehensive summary.", detail: "Detailed coverage. Include formulas, examples, and nuances. Preserve structure." },
    "5": { purpose: "Create an exhaustive reference document.", detail: "Include EVERYTHING. Formulas, proofs, examples, edge cases. This should serve as complete study notes." }
};

const DEFAULT_SETTINGS = {
    apiKey: "", // Fallback if provider missing
    model: "google/gemini-2.0-flash-exp:free",
    language: "German",
    apiUrl: "https://openrouter.ai/api/v1/chat/completions",
    defaultDetailLevel: "3",
    saveLocation: "inline",
    cardStyle: "single",
    customInstructions: "",
    // Advanced settings
    advancedMode: false,
    flashcardPrompts: JSON.parse(JSON.stringify(DEFAULT_FLASHCARD_PROMPTS)),
    summaryPrompts: JSON.parse(JSON.stringify(DEFAULT_SUMMARY_PROMPTS)),
    // modelContextLengths now from provider
    modelContextLengths: {}
};

module.exports = class AILearningAssistant extends Plugin {
    async onload() {
        await this.loadSettings();

        // Status bar item for progress
        this.statusBarItem = this.addStatusBarItem();
        this.statusBarItem.setText('');
        this.statusBarItem.addClass('ai-learning-status');

        this.addRibbonIcon('brain-circuit', 'AI Learning Assistant', (evt) => {
            new LearningAssistantModal(this.app, this).open();
        });

        this.addCommand({
            id: 'open-learning-assistant',
            name: 'Open Learning Assistant',
            callback: () => {
                new LearningAssistantModal(this.app, this).open();
            }
        });

        this.addCommand({
            id: 'generate-flashcards',
            name: 'Generate Flashcards',
            callback: () => {
                new LearningAssistantModal(this.app, this, 'flashcards').open();
            }
        });

        this.addCommand({
            id: 'generate-summary',
            name: 'Generate Summary',
            callback: () => {
                new LearningAssistantModal(this.app, this, 'summary').open();
            }
        });

        this.addCommand({
            id: 'create-learning-environment',
            name: 'Create Learning Environment',
            callback: () => {
                new LearningAssistantModal(this.app, this, 'environment').open();
            }
        });

        this.addSettingTab(new AILearningSettingTab(this.app, this));

        // Sync with Provider on load
        this.app.workspace.onLayoutReady(() => {
            const provider = this.getProvider();
            if (provider && this.settings.model && typeof provider.setModel === 'function') {
                provider.setModel('ai-flashcards', this.settings.model);
            }
        });
    }

    // ==================== PROVIDER ACCESS ====================
    getProvider() {
        const provider = this.app.plugins.getPlugin('openrouter-provider');
        // Silent return null if not found
        return provider || null;
    }

    async fetchWithRetry(requestBody, retries = 5, delay = 5000) {
        // 1. Try Provider
        const provider = this.getProvider();
        let apiKey = provider ? provider.getApiKey() : null;

        // 2. Fallback to Local Settings
        if (!apiKey) {
            apiKey = this.settings.apiKey;
        }

        if (!apiKey) {
            throw new Error("API Key not found. Please enable OpenRouter Provider OR set a key in settings.");
        }

        // Active Model Indicator (Top Right Toast, 5s)
        new Notice(`ü§ñ Generating with ${requestBody.model}...`, 5000);

        for (let i = 0; i < retries; i++) {
            try {
                this.setStatus(`API call... (try ${i + 1})`);
                const response = await requestUrl({
                    url: this.settings.apiUrl,
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${apiKey}`,
                        "HTTP-Referer": "https://obsidian.md",
                        "X-Title": "Obsidian AI Learning Assistant"
                    },
                    body: JSON.stringify(requestBody)
                });

                if (response.status === 429) {
                    const waitSec = Math.round(delay / 1000);
                    this.setStatus(`Rate limit! Wait ${waitSec}s...`);
                    new Notice(`‚ö†Ô∏è Rate Limit! Waiting ${waitSec}s... (Retry ${i + 1}/${retries})`);
                    await new Promise(r => setTimeout(r, delay));
                    delay *= 2;
                    continue;
                }

                if (response.status >= 400) {
                    let errorMsg = `API Error ${response.status}`;
                    try {
                        const errJson = response.json;
                        if (errJson?.error?.message) errorMsg += `: ${errJson.error.message}`;
                    } catch (e) {
                        errorMsg += `: ${response.text?.substring(0, 100) || 'Unknown error'}`;
                    }
                    throw new Error(errorMsg);
                }

                // OUTPUT CLEANING: Remove <think> tags (deepseek/reasoning models)
                if (response.json && response.json.choices && response.json.choices.length > 0) {
                    let content = response.json.choices[0].message.content;
                    // Regex to remove <think>...</think> including newlines
                    content = content.replace(/<think>[\s\S]*?<\/think>/gi, "").trim();
                    response.json.choices[0].message.content = content;
                }

                return response;

            } catch (error) {
                console.error('AI Learning Assistant Error:', error);
                if (i === retries - 1) {
                    this.setStatus(`Failed: ${error.message.substring(0, 30)}...`);
                    throw error;
                }
                new Notice(`‚ö†Ô∏è ${error.message} - Retrying (${i + 1}/${retries})...`);
                await new Promise(r => setTimeout(r, delay));
                delay *= 1.5;
            }
        }
    }

    async fetchCredits() {
        const provider = this.getProvider();
        if (!provider) return null;
        return provider.fetchCredits();
    }

    getContent() {
        const activeView = this.app.workspace.getActiveViewOfType(require("obsidian").MarkdownView);
        if (!activeView) return null;
        const editor = activeView.editor;
        return {
            text: editor.getSelection() || editor.getValue(),
            editor: editor,
            file: activeView.file
        };
    }

    // ==================== FLASHCARD GENERATION ====================
    async generateFlashcards(options) {
        const content = this.getContent();
        if (!content) { new Notice("No active markdown note."); return; }
        if (content.text.trim().length < 50) { new Notice("‚ö†Ô∏è Content too short."); return; }
        if (!this.getProvider()) { return; }

        const usedModel = options.model || this.settings.model;
        const contextLimit = this.settings.modelContextLengths?.[usedModel] || 128000;
        // Flashcards output is verbose, reserve more space (e.g. 5k tokens)
        const CHUNK_SIZE = Math.max(8000, Math.floor((contextLimit - 5000) * 3));

        const chunks = [];
        for (let i = 0; i < content.text.length; i += CHUNK_SIZE) {
            chunks.push(content.text.substring(i, i + CHUNK_SIZE));
        }

        new Notice(`üß† Generating flashcards (${chunks.length} chunks)...`);
        let allCards = [];
        const basePrompt = this.buildFlashcardPrompt(options);

        for (let i = 0; i < chunks.length; i++) {
            const chunk = chunks[i];
            new Notice(`üß† Chunk ${i + 1}/${chunks.length}...`);

            let targetDivisor = 800;
            if (options.detailLevel === "1") targetDivisor = 2000;
            if (options.detailLevel === "2") targetDivisor = 1200;
            if (options.detailLevel === "4") targetDivisor = 500;
            if (options.detailLevel === "5") targetDivisor = 250;

            const target = Math.ceil(chunk.length / targetDivisor);
            const quantityInstruction = options.cardCount !== "Auto"
                ? `Generate EXACTLY ${Math.ceil(parseInt(options.cardCount) / chunks.length)} flashcards.`
                : `Generate roughly ${target} flashcards.`;

            const fcCustom = options.flashcardCustomInstructions
                ? `\n\n‚ö†Ô∏è IMPORTANT - USER CUSTOM INSTRUCTIONS (APPLY TO CONTENT, NOT FORMAT):\n${options.flashcardCustomInstructions}\n\nRemember: Apply these instructions to the CONTENT and STYLE of questions/answers, but ALWAYS keep the MANDATORY FORMAT above!`
                : "";
            const fullPrompt = `${basePrompt}\n\nQUANTITY: ${quantityInstruction}${fcCustom}`;
            const lang = this.settings.language || "German";

            try {
                const response = await this.fetchWithRetry({
                    model: options.model || this.settings.model,
                    messages: [
                        { role: "system", content: fullPrompt },
                        { role: "user", content: `TEXT:\n${chunk}\n\nOUTPUT IN ${lang.toUpperCase()}.` }
                    ]
                });

                const json = response.json;
                if (json.choices && json.choices.length > 0) {
                    let text = json.choices[0].message.content.trim();
                    text = text.replace(/^```markdown\s*/, "").replace(/```$/, "");
                    // Clean LaTeX delimiters
                    text = this.cleanLatexDelimiters(text);
                    if (text.length > 10) allCards.push(text);
                }
            } catch (err) {
                new Notice(`‚ùå Chunk ${i + 1} failed: ${err.message}`);
            }
        }

        if (allCards.length === 0) { new Notice("‚ùå No cards generated."); return; }

        const output = `\n\n---\n### üß† Flashcards (Level ${options.detailLevel})\n\n${allCards.join("\n\n")}\n\n`;

        if (options.saveLocation === "folder") {
            const tag = this.generateTag(content.file);
            const taggedOutput = `${tag}\n${output}`;
            await this.saveToFolder(content.file, taggedOutput, "Flashcards", "_Cards");
        } else {
            content.editor.replaceRange(output, content.editor.getCursor("to"));
            new Notice("‚úÖ Flashcards generated!");
        }
    }

    buildFlashcardPrompt(options) {
        const prompts = this.settings.advancedMode ? this.settings.flashcardPrompts : DEFAULT_FLASHCARD_PROMPTS;
        const cfg = prompts[options.detailLevel] || prompts["3"];
        const lang = this.settings.language || "German";

        // Multiple choice instruction
        const mcInstruction = options.multipleChoice
            ? `\n\nüîò MULTIPLE CHOICE MODE (MANDATORY):
- Create multiple choice questions with EXACTLY ${options.choiceCount} options labeled A), B), C), D), E) as needed
- Put ALL choices in the QUESTION part
- Put ONLY the correct letter (e.g., "A" or "B") in the ANSWER part
- Make one option clearly correct, others plausible but wrong
- CRITICAL: RANDOMIZE which letter is correct! Do NOT always use A!
  - Vary answers across A, B, C, D roughly equally
  - Example: first card answer=C, second=A, third=D, fourth=B, etc.
- Example format:
What is 2+2?
A) 3
B) 4
C) 5
D) 6
?
B`
            : "";

        let format = options.cardStyle === "multi"
            ? `FORMAT (MANDATORY - DO NOT CHANGE):
Question text here
?
Answer text here

Another question
?
Another answer

CRITICAL FORMAT RULES:
- Each card has: question, then IMMEDIATELY a line with ONLY "?", then the answer
- NO blank line between question and "?" - they must be adjacent!
- Blank line ONLY between cards (after answer, before next question)
- The "?" on its own line is the SEPARATOR - this is required!
- NO "::" separator allowed when using this format
- NO "---" horizontal rules between cards!
- NO headers like "### Flashcards" or section titles!${mcInstruction}`
            : `FORMAT (MANDATORY - DO NOT CHANGE): Question::Answer
CRITICAL FORMAT RULES:
- One card per line using "::" as separator
- No intro/outro text
- NO "?" separator allowed when using this format`;

        const custom = this.settings.customInstructions ? `\nCUSTOM: ${this.settings.customInstructions}` : "";

        return `You are a strict flashcard generator.
GOAL: ${cfg.purpose}
DETAIL: ${cfg.detail}
LANGUAGE: ${lang}
MATH SUPPORT: Use Obsidian-compatible LaTeX (MathJax).
- Inline Math: $ a^2 + b^2 = c^2 $
- Block Math: $$ \frac{a}{b} $$
- STRICTLY AVOID Typst syntax (no $ x "text" $ or #let).
- Do NOT USE \[ ... \] for math blocks!!! Use $$...$$for math blocks or $...$ for inline math!!!
VISUAL STYLING:
- Use **bold** for key terms.

${format}

STYLE ADAPTATION:
1. First, analyze the Document Style. Is it Conceptual (explaining 'why'/'how') or Technical (formulas, proofs, calculations)?
2. If Conceptual: Focus flashcards on understanding, mechanisms, and cause-effect relationships. Avoid isolated formulas.
3. If Technical: Focus on formulas, conditions, and calculation steps.
4. "Leitfragen" / Example Questions: If present, use them as the GOLD STANDARD for card style. If the text asks "Explain the concept of...", do NOT generate a formula card for that concept.
5. Mimic the depth and tone of the source text.
${custom}
Output ONLY raw cards using the MANDATORY FORMAT above.`;
    }

    // ==================== SUMMARY GENERATION ====================


    async generateSummary(options) {
        const content = this.getContent();
        if (!content) { new Notice("No active markdown note."); return; }
        if (content.text.trim().length < 50) { new Notice("‚ö†Ô∏è Content too short."); return; }
        if (!this.getProvider()) { return; }

        const usedModel = options.model || this.settings.model;
        const contextLimit = this.settings.modelContextLengths?.[usedModel] || 128000;
        const CHUNK_SIZE = Math.max(10000, Math.floor((contextLimit - 4000) * 3));

        const chunks = [];
        for (let i = 0; i < content.text.length; i += CHUNK_SIZE) {
            chunks.push(content.text.substring(i, i + CHUNK_SIZE));
        }

        new Notice(`üìù Generating summary (${chunks.length} chunks)...`);
        let allSummaries = [];
        let previousSummary = "";
        const basePrompt = this.buildSummaryPrompt(options);
        const sumCustom = options.summaryCustomInstructions
            ? `\nCUSTOM INSTRUCTIONS: ${options.summaryCustomInstructions}`
            : "";

        for (let i = 0; i < chunks.length; i++) {
            new Notice(`üìù Chunk ${i + 1}/${chunks.length}...`);

            // Construct User Prompt with Context
            let userPrompt = "";
            if (previousSummary) {
                userPrompt += `<previous_context_do_not_output>\n${previousSummary}\n</previous_context_do_not_output>\n\n`;
            }
            userPrompt += `<new_text_to_summarize>\n${chunks[i]}\n</new_text_to_summarize>\n\n` +
                `INSTRUCTION: Summarize ONLY the content inside <new_text_to_summarize>. ` +
                `The <previous_context> is for continuity ONLY. Do not re-summarize it. ` +
                `OUTPUT IN ${this.settings.language.toUpperCase()}.`;

            try {
                const response = await this.fetchWithRetry({
                    model: options.model || this.settings.model,
                    messages: [
                        { role: "system", content: basePrompt + sumCustom },
                        { role: "user", content: userPrompt }
                    ]
                });

                const json = response.json;
                if (json.choices && json.choices.length > 0) {
                    let text = json.choices[0].message.content.trim();
                    text = text.replace(/^```markdown\s*/, "").replace(/```$/, "");
                    // Clean LaTeX delimiters
                    text = this.cleanLatexDelimiters(text);

                    if (text.length > 10) {
                        allSummaries.push(text);
                        // Update context for next chunk (keep it concise if possible, but full summary is safer for continuity)
                        previousSummary = text;
                    }
                }
            } catch (err) {
                new Notice(`‚ùå Chunk ${i + 1} failed: ${err.message}`);
            }
        }

        if (allSummaries.length === 0) { new Notice("‚ùå No summary generated."); return; }

        // If multiple chunks, combine summaries
        let finalSummary = allSummaries.join("\n\n---\n\n");

        const output = `\n\n---\n### üìù Summary (Level ${options.detailLevel})\n\n${finalSummary}\n\n`;

        if (options.saveLocation === "folder") {
            await this.saveToFolder(content.file, output, "Summaries", "_Summary");
        } else {
            content.editor.replaceRange(output, content.editor.getCursor("to"));
            new Notice("‚úÖ Summary generated!");
        }
    }

    // ==================== LEARNING ENVIRONMENT (Summary -> Flashcards) ====================
    async generateLearningEnvironment(options) {
        const content = this.getContent();
        if (!content) { new Notice("No active markdown note."); return; }
        if (content.text.trim().length < 50) { new Notice("‚ö†Ô∏è Content too short."); return; }
        if (!this.getProvider()) { return; }

        this.setStatus("Preparing...");

        // Create Learning folder
        const parentDir = content.file.parent.path;
        const learningDir = `${parentDir}/Learning`;
        if (!(await this.app.vault.adapter.exists(learningDir))) {
            await this.app.vault.createFolder(learningDir);
        }

        // STEP 1: Generate Summary
        this.setStatus("Step 1/2: Summary...");
        new Notice(`üìö Step 1/2: Generating Summary (Level ${options.detailLevel})...`);

        const usedModel = options.model || this.settings.model;
        const contextLimit = this.settings.modelContextLengths?.[usedModel] || 128000;
        const CHUNK_SIZE = Math.max(10000, Math.floor((contextLimit - 4000) * 3));

        const chunks = [];
        for (let i = 0; i < content.text.length; i += CHUNK_SIZE) {
            chunks.push(content.text.substring(i, i + CHUNK_SIZE));
        }

        let allSummaries = [];
        let previousSummary = "";
        const summaryPrompt = this.buildSummaryPrompt(options);
        const envSummaryCustom = options.envSummaryCustomInstructions
            ? `\nCUSTOM INSTRUCTIONS: ${options.envSummaryCustomInstructions}`
            : "";

        for (let i = 0; i < chunks.length; i++) {
            this.setStatus(`Summary ${i + 1}/${chunks.length}...`);
            new Notice(`üìù Summary chunk ${i + 1}/${chunks.length}...`);

            // Construct User Prompt with Context
            let userPrompt = "";
            if (previousSummary) {
                userPrompt += `<previous_context_do_not_output>\n${previousSummary}\n</previous_context_do_not_output>\n\n`;
            }
            userPrompt += `<new_text_to_summarize>\n${chunks[i]}\n</new_text_to_summarize>\n\n` +
                `INSTRUCTION: Summarize ONLY the content inside <new_text_to_summarize>. ` +
                `The <previous_context> is for continuity ONLY. Do not re-summarize it. ` +
                `OUTPUT IN ${this.settings.language.toUpperCase()}.`;

            try {
                const response = await this.fetchWithRetry({
                    model: options.model || this.settings.model,
                    messages: [
                        { role: "system", content: summaryPrompt + envSummaryCustom },
                        { role: "user", content: userPrompt }
                    ]
                });
                const json = response.json;
                if (json.choices && json.choices.length > 0) {
                    let text = json.choices[0].message.content.trim();
                    text = text.replace(/^```markdown\s*/, "").replace(/```$/, "");
                    // Clean LaTeX delimiters
                    text = this.cleanLatexDelimiters(text);

                    if (text.length > 10) {
                        allSummaries.push(text);
                        // Update context
                        previousSummary = text;
                    }
                }
            } catch (err) {
                new Notice(`‚ùå Summary chunk ${i + 1} failed: ${err.message}`);
            }
        }

        if (allSummaries.length === 0) {
            this.clearStatus();
            new Notice("‚ùå Failed to generate summary.");
            return;
        }

        const summary = allSummaries.join("\n\n");

        // Save summary
        this.setStatus("Saving summary...");
        const summaryPath = `${learningDir}/${content.file.basename}_Summary.md`;
        const summaryContent = `# Summary: ${content.file.basename}\nSource: [[${content.file.path}]]\nLevel: ${options.detailLevel}\n\n---\n\n${summary}`;
        await this.app.vault.create(summaryPath, summaryContent).catch(async () => {
            const file = this.app.vault.getAbstractFileByPath(summaryPath);
            if (file) await this.app.vault.modify(file, summaryContent);
        });
        new Notice(`‚úÖ Summary saved!`);

        // STEP 2: Generate Flashcards from Summary
        this.setStatus("Step 2/2: Flashcards...");
        new Notice(`üìö Step 2/2: Generating Flashcards from Summary...`);

        const isMultiLine = options.cardStyle === 'multi';

        // Multiple choice instruction for Learning Environment
        const envMcInstruction = options.envMultipleChoice
            ? `\n\nüîò MULTIPLE CHOICE MODE (MANDATORY):
- Create multiple choice questions with EXACTLY ${options.envChoiceCount} options labeled A), B), C), D), E) as needed
- Put ALL choices in the QUESTION part
- Put ONLY the correct letter (e.g., "A" or "B") in the ANSWER part
- Make one option clearly correct, others plausible but wrong
- CRITICAL: RANDOMIZE which letter is correct! Do NOT always use A!
  - Vary answers across A, B, C, D roughly equally
  - Example: first card answer=C, second=A, third=D, fourth=B, etc.
- Example format:
What is 2+2?
A) 3
B) 4
C) 5
D) 6
?
B`
            : "";

        const flashcardPrompt = isMultiLine
            ? `You are a flashcard generator.

FORMAT (MANDATORY - DO NOT CHANGE):
The question text here
?
The answer text here

Another question
?
Another answer

CRITICAL FORMAT RULES:
- Each card has: question, then IMMEDIATELY a line with ONLY "?", then the answer
- NO blank line between question and "?" - they must be adjacent!
- Blank line ONLY between cards (after answer, before next question)
- The "?" on its own line is the SEPARATOR - this is REQUIRED!
- NO "::" separator allowed when using this format
- NO "---" horizontal rules between cards!
- NO headers like "### Flashcards" or section titles!
- NO labels like "Question:" or "Answer:"
- NO numbering
- STYLE ADAPTATION: Analyze the text. If it explains CONCEPTS, generate CONCEPTUAL cards (explain why/how). If it derives FORMULAS, generate MATH cards. If it has example questions, MIMIC THEIR STYLE exactly. Match the source text's depth.
- One fact per card
- Language: ${this.settings.language}
- MATH SUPPORT: Use MathJax (LaTeX). Inline: $...$, Block: $$...$$. NO Typst.
- Output ONLY cards using the MANDATORY FORMAT above, no other text${envMcInstruction}`
            : `You are a flashcard generator.

FORMAT (MANDATORY - DO NOT CHANGE): Question::Answer

Example:
What is X?::X is the definition here
What does Y do?::Y performs this function
Define Z::Z means this

CRITICAL FORMAT RULES:
- Format: question::answer (double colon separator)
- One card per line
- NO "?" separator allowed when using this format
- NO labels like "Question:" or "Answer:"
- NO numbering, NO bullet points
- STYLE ADAPTATION: Analyze the text. If it explains CONCEPTS, generate CONCEPTUAL cards (explain why/how). If it derives FORMULAS, generate MATH cards. If it has example questions, MIMIC THEIR STYLE exactly. Match the source text's depth.
- One fact per card
- Language: ${this.settings.language}
- MATH SUPPORT: Use MathJax (LaTeX). Inline: $...$, Block: $$...$$. NO Typst.
- VISUALS: Use **bold** for terms
- Output ONLY cards, no other text`;

        const envCustom = options.envCustomInstructions
            ? `\n\n‚ö†Ô∏è IMPORTANT - USER CUSTOM INSTRUCTIONS (APPLY TO CONTENT, NOT FORMAT):\n${options.envCustomInstructions}\n\nRemember: Apply these instructions to the CONTENT and STYLE of questions/answers, but ALWAYS keep the MANDATORY FORMAT above (use ? separator, never ::)!`
            : "";

        try {
            const response = await this.fetchWithRetry({
                model: options.model || this.settings.model,
                messages: [
                    { role: "system", content: flashcardPrompt + envCustom },
                    { role: "user", content: `SUMMARY:\n${summary}\n\nGenerate flashcards in ${this.settings.language.toUpperCase()}.` }
                ]
            });

            const json = response.json;
            if (json.choices && json.choices.length > 0) {
                let cards = json.choices[0].message.content.trim();
                cards = cards.replace(/^```markdown\s*/, "").replace(/```$/, "");
                // Clean LaTeX delimiters
                cards = this.cleanLatexDelimiters(cards);

                this.setStatus("Saving flashcards...");
                const cardsPath = `${learningDir}/${content.file.basename}_Flashcards.md`;

                const tag = this.generateTag(content.file);
                const cardsContent = `${tag}\n# Flashcards: ${content.file.basename}\nSource: [[${content.file.path}]]\nGenerated from: [[${summaryPath}]]\n\n---\n\n${cards}`;
                await this.app.vault.create(cardsPath, cardsContent).catch(async () => {
                    const file = this.app.vault.getAbstractFileByPath(cardsPath);
                    if (file) await this.app.vault.modify(file, cardsContent);
                });
                this.clearStatus();
                new Notice(`‚úÖ Learning Environment created!\nüìÅ ${learningDir}`);
            }
        } catch (err) {
            this.clearStatus();
            new Notice(`‚ùå Flashcard generation failed: ${err.message}`);
        }
    }

    buildSummaryPrompt(options) {
        const prompts = this.settings.advancedMode ? this.settings.summaryPrompts : DEFAULT_SUMMARY_PROMPTS;
        const cfg = prompts[options.detailLevel] || prompts["3"];
        const lang = this.settings.language || "German";
        const custom = this.settings.customInstructions ? `\nCUSTOM: ${this.settings.customInstructions}` : "";

        return `You are an expert note summarizer.
GOAL: ${cfg.purpose}
DETAIL LEVEL: ${cfg.detail}
LANGUAGE: ${lang}
FORMAT: Use markdown with headers. Use MathJax (LaTeX) for math. DO NOT use Typst.
VISUALS:
- Use ==highlights== for key terms.
- Use **Mermaid Diagrams** (\`\`\`mermaid) for processes, flows, or hierarchies.
  IMPORTANT MERMAID RULES:
  1. Use the "Academic Blue" color scheme for ALL Mermaid diagrams:
     - Primary/Main color: #184a85 (dark blue) - use for main nodes, borders, arrows
     - Accent background: #f2f6fa (light blue-grey) - use for node fills
     - Result/highlight: #e6fffa (light cyan) - use for emphasized/result nodes
     - Text color: #1a1a1a (dark grey)
  2. CRITICAL SYNTAX RULES to prevent parsing errors:
     - NEVER use invisible/non-breaking spaces - use only standard spaces
     - Use standard spaces for indentation, NOT tabs or special whitespace
     - ALWAYS wrap node labels containing special characters in double quotes ""
      - Special characters that REQUIRE quotes: ‚Üí ‚Üê ‚Üî ‚ÇÇ ‚ÇÉ ‚Å∫ ‚Åª ¬∞ ‚â† ‚â§ ‚â• ‚àû ‚àù _ etc.
      - Mermaid labels do NOT support LaTeX ($...$). Avoid LaTeX inside labels.
      - If you need Greek letters, use Unicode (e.g., "œÉ") inside quotes, or plain text (e.g., "sigma").
    - Prefer ASCII operators in labels (use ">=" instead of "‚â•", "<=" instead of "‚â§").
     - Example: D["Metall ‚Üí Metall-Ionen + e‚Åª"] NOT D[Metall ‚Üí Metall-Ionen + e‚Åª]
     - Mathematical operations like + or - in labels are misread without quotes
  3. Example with correct theming and syntax:
  \`\`\`mermaid
  %%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#f2f6fa', 'primaryBorderColor': '#184a85', 'primaryTextColor': '#1a1a1a', 'lineColor': '#184a85', 'secondaryColor': '#e6fffa', 'tertiaryColor': '#fff9e6'}}}%%
  graph LR
      A[Metall] --> B["Prozess mit O‚ÇÇ"]
      style A fill:#f2f6fa,stroke:#184a85
  \`\`\`
- Use **Markdown Tables** for comparisons.
Preserve important formulas and definitions.
LEITFRAGEN: If the text contains Leitfragen (guiding questions), include them in the summary under an appropriate heading.${custom}
Output ONLY the summary, no meta-commentary.`;
    }

    // ==================== UTILITIES ====================
    generateTag(file) {
        // Tag format: #flashcards/ParentFolder (spaces -> underscores, no spaces around /)
        const parent = file.parent ? file.parent.name : "root";
        const cleanParent = parent.replace(/\s+/g, '_');
        // If parent is "Learning" or "Flashcards" or "misc", go up one level
        if (["Learning", "Flashcards", "misc", "Summaries"].includes(parent)) {
            const grandParent = file.parent.parent ? file.parent.parent.name : "root";
            return `#flashcards/${grandParent.replace(/\s+/g, '_')}`;
        }
        return `#flashcards/${cleanParent}`;
    }

    async saveToFolder(sourceFile, content, folderName, suffix) {
        const parentDir = sourceFile.parent.path;
        const targetDir = `${parentDir}/${folderName}`;
        if (!(await this.app.vault.adapter.exists(targetDir))) {
            await this.app.vault.createFolder(targetDir);
        }
        const targetPath = `${targetDir}/${sourceFile.basename}${suffix}.md`;

        if (await this.app.vault.adapter.exists(targetPath)) {
            const file = this.app.vault.getAbstractFileByPath(targetPath);
            await this.app.vault.modify(file, (await this.app.vault.read(file)) + content);
            new Notice(`‚úÖ Appended to: ${targetPath}`);
        } else {
            await this.app.vault.create(targetPath, `# ${folderName}: ${sourceFile.basename}\nSource: [[${sourceFile.path}]]\n${content}`);
            new Notice(`‚úÖ Created: ${targetPath}`);
        }
    }

    async loadSettings() { this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData()); }
    async saveSettings() { await this.saveData(this.settings); }

    // LaTeX delimiter cleaner - replaces \[ ... \] with $$ ... $$ and \( ... \) with $ ... $
    // Also cleans problematic whitespace characters (non-breaking spaces, etc.)
    cleanLatexDelimiters(text) {
        if (!text) return text;

        // Clean non-breaking spaces (U+00A0) and other problematic whitespace
        // Replace all non-breaking spaces with regular spaces
        text = text.replace(/\u00A0/g, ' ');
        // Replace other problematic Unicode whitespace characters
        text = text.replace(/[\u2000-\u200B\u202F\u205F\u3000]/g, ' ');

        // Replace \[ content \] blocks with proper $$ formatting
        // Matches \[ followed by any content (including newlines) followed by \]
        text = text.replace(/\\\[\s*([\s\S]*?)\s*\\\]/g, (match, content) => {
            // Trim the content and wrap with $$ on separate lines
            const trimmedContent = content.trim();
            return `$$\n${trimmedContent}\n$$`;
        });
        // Replace \( content \) inline math with $ ... $
        // Matches \( followed by any content (non-greedy) followed by \)
        text = text.replace(/\\\(\s*(.*?)\s*\\\)/g, (match, content) => {
            const trimmedContent = content.trim();
            return `$${trimmedContent}$`;
        });
        return text;
    }

    // Status bar helpers
    setStatus(text) {
        if (this.statusBarItem) {
            this.statusBarItem.setText(text ? `üß† ${text}` : '');
        }
    }
    clearStatus() {
        if (this.statusBarItem) {
            this.statusBarItem.setText('');
        }
    }
}

// ==================== MODAL WITH TABS ====================
class LearningAssistantModal extends Modal {
    constructor(app, plugin, defaultTab = 'flashcards') {
        super(app);
        this.plugin = plugin;
        this.activeTab = defaultTab;
        this.options = {
            detailLevel: plugin.settings.defaultDetailLevel,
            cardCount: "Auto",
            saveLocation: plugin.settings.saveLocation,
            cardStyle: plugin.settings.cardStyle,
            model: plugin.settings.model,
            envCustomInstructions: "",
            envSummaryCustomInstructions: "",
            flashcardCustomInstructions: "",
            summaryCustomInstructions: "",
            multipleChoice: false,
            choiceCount: "4",
            envMultipleChoice: false,
            envChoiceCount: "4"
        };
    }

    onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass('ai-learning-modal');

        // Title
        contentEl.createEl("h2", { text: "üß† AI Learning Assistant" });

        // Tab bar
        const tabBar = contentEl.createDiv({ cls: "tab-bar" });
        tabBar.style.display = "flex";
        tabBar.style.gap = "0";
        tabBar.style.marginBottom = "16px";
        tabBar.style.borderBottom = "2px solid var(--background-modifier-border)";

        const flashcardsTab = tabBar.createEl("button", { text: "üé¥ Flashcards" });
        const summaryTab = tabBar.createEl("button", { text: "üìù Summary" });
        const environmentTab = tabBar.createEl("button", { text: "üìö Learning Env" });

        [flashcardsTab, summaryTab, environmentTab].forEach(tab => {
            tab.style.padding = "8px 16px";
            tab.style.border = "none";
            tab.style.background = "transparent";
            tab.style.cursor = "pointer";
            tab.style.fontSize = "14px";
            tab.style.borderBottom = "2px solid transparent";
            tab.style.marginBottom = "-2px";
        });

        const contentDiv = contentEl.createDiv({ cls: "tab-content" });

        const setActiveTab = (tab) => {
            this.activeTab = tab;
            // Reset detail level to 4 for environment tab
            if (tab === 'environment' && this.options.detailLevel !== "4") {
                this.options.detailLevel = "4";
            }
            flashcardsTab.style.borderBottomColor = tab === 'flashcards' ? 'var(--interactive-accent)' : 'transparent';
            flashcardsTab.style.color = tab === 'flashcards' ? 'var(--interactive-accent)' : '';
            summaryTab.style.borderBottomColor = tab === 'summary' ? 'var(--interactive-accent)' : 'transparent';
            summaryTab.style.color = tab === 'summary' ? 'var(--interactive-accent)' : '';
            environmentTab.style.borderBottomColor = tab === 'environment' ? 'var(--interactive-accent)' : 'transparent';
            environmentTab.style.color = tab === 'environment' ? 'var(--interactive-accent)' : '';
            this.renderTabContent(contentDiv);
        };

        flashcardsTab.onclick = () => setActiveTab('flashcards');
        summaryTab.onclick = () => setActiveTab('summary');
        environmentTab.onclick = () => setActiveTab('environment');

        setActiveTab(this.activeTab);
    }

    renderTabContent(container) {
        container.empty();

        // --- NEW: Model Selector & Balance ---
        // --- NEW: Model Selector & Balance (Standardized) ---

        // Prepare favorites
        // Prepare favorites - Use provider's favorites or default
        const provider = this.plugin.getProvider();

        const modelSetting = new Setting(container)
            .setName("Model")
            .addDropdown(d => {
                const refreshOptions = () => {
                    const favorites = provider && provider.getFavorites ? provider.getFavorites() : [];
                    const currentVal = this.options.model;
                    d.selectEl.innerHTML = "";
                    // Ensure current model is in list
                    if (!favorites.includes(currentVal)) {
                        d.addOption(currentVal, currentVal.split('/').pop());
                    }
                    favorites.forEach(f => d.addOption(f, f.split('/').pop()));
                    d.setValue(currentVal);
                };

                refreshOptions();

                if (provider) {
                    d.selectEl.addEventListener('mousedown', refreshOptions);
                    d.onChange(async v => {
                        this.options.model = v;
                        this.plugin.settings.model = v;
                        await this.plugin.saveSettings();
                    });
                } else {
                    // Standalone: simple display or basic select
                    d.selectEl.title = "Manually set model in settings";
                }
            })
            .addButton(btn => {
                btn.setButtonText("Browse");
                if (provider) {
                    btn.onClick(() => {
                        provider.openModelSelector('ai-flashcards', (modelId) => {
                            this.options.model = modelId;
                            this.plugin.settings.model = modelId;
                            this.plugin.saveSettings();
                            this.renderTabContent(container);
                        });
                    });
                } else {
                    btn.setDisabled(true);
                    btn.setTooltip("Requires OpenRouter Provider plugin");
                }
            });

        // Balance check or Standalone Status
        const descEl = modelSetting.descEl.createDiv({ cls: 'ai-balance-desc' });
        descEl.style.fontSize = '0.8em';
        descEl.style.color = 'var(--text-muted)';

        if (provider) {
            descEl.setText("Loading balance...");
            provider.fetchCredits().then(c => {
                descEl.setText(c ? `Credits: $${c}` : 'Credits: ???');
            });
        } else {
            descEl.setText("‚ö†Ô∏è Standalone Mode");
            descEl.style.color = 'var(--text-warning)';
        }

        // Environment tab has special UI
        if (this.activeTab === 'environment') {
            container.createEl('p', {
                text: 'Creates a Summary ‚Üí Flashcards pipeline. Both are saved to a Learning/ folder.',
                cls: 'setting-item-description'
            });

            // Summary Level Slider
            const sliderSetting = new Setting(container)
                .setName("Summary Detail Level")
                .setDesc("How detailed should the summary be? (Default: 4)");

            const sliderContainer = sliderSetting.controlEl.createDiv({ cls: "slider-container" });
            sliderContainer.style.display = "flex";
            sliderContainer.style.alignItems = "center";

            const levelLabel = sliderContainer.createEl("span", {
                text: this.getLevelLabel(this.options.detailLevel),
                cls: "level-label"
            });
            levelLabel.style.marginRight = "10px";
            levelLabel.style.fontWeight = "bold";
            levelLabel.style.minWidth = "100px";

            const slider = sliderContainer.createEl("input", {
                type: "range",
                attr: { min: "1", max: "5", step: "1" }
            });
            slider.value = this.options.detailLevel;
            slider.style.width = "120px";
            slider.addEventListener("input", (e) => {
                this.options.detailLevel = e.target.value;
                levelLabel.textContent = this.getLevelLabel(e.target.value);
            });

            // Card Style
            new Setting(container)
                .setName("Card Style")
                .addDropdown(d => d
                    .addOption("single", "Single-line (::)")
                    .addOption("multi", "Multi-line (?)")
                    .setValue(this.options.cardStyle)
                    .onChange(v => this.options.cardStyle = v)
                );

            // Multiple Choice Toggle
            const envMcContainer = container.createDiv({ cls: 'mc-options-container' });
            const envChoiceCountSetting = new Setting(envMcContainer)
                .setName("Number of Choices")
                .setDesc("How many answer options per question")
                .addDropdown(d => d
                    .addOption("2", "2")
                    .addOption("3", "3")
                    .addOption("4", "4")
                    .addOption("5", "5")
                    .setValue(this.options.envChoiceCount)
                    .onChange(v => this.options.envChoiceCount = v)
                );
            envChoiceCountSetting.settingEl.style.display = this.options.envMultipleChoice ? 'flex' : 'none';

            new Setting(container)
                .setName("üîò Multiple Choice")
                .setDesc("Generate questions with A/B/C/D answer options")
                .addToggle(toggle => {
                    toggle.setValue(this.options.envMultipleChoice);
                    toggle.onChange(v => {
                        this.options.envMultipleChoice = v;
                        envChoiceCountSetting.settingEl.style.display = v ? 'flex' : 'none';
                    });
                });
            container.appendChild(envMcContainer);

            // Advanced Options Toggle
            const advancedContainer = container.createDiv({ cls: 'advanced-options-container' });
            const advancedContent = advancedContainer.createDiv({ cls: 'advanced-content' });
            advancedContent.style.display = 'none';
            advancedContent.style.marginTop = '8px';
            advancedContent.style.paddingLeft = '12px';
            advancedContent.style.borderLeft = '2px solid var(--interactive-accent)';

            const advancedToggle = new Setting(advancedContainer)
                .setName("‚öôÔ∏è Advanced Options")
                .setDesc("Custom instructions for summary and flashcards")
                .addToggle(toggle => {
                    toggle.setValue(false);
                    toggle.onChange(v => {
                        advancedContent.style.display = v ? 'block' : 'none';
                    });
                });

            // Move advancedContent after the toggle visually
            advancedContainer.appendChild(advancedContent);

            // Summary Custom Instructions
            new Setting(advancedContent)
                .setName("Summary Custom Instructions")
                .setDesc("Optional: extra rules for summary generation.")
                .addTextArea(text => {
                    text.setPlaceholder("E.g., focus on formulas, ignore examples...")
                        .setValue(this.options.envSummaryCustomInstructions || "")
                        .onChange(v => this.options.envSummaryCustomInstructions = v || "");
                    text.inputEl.style.width = "100%";
                    text.inputEl.style.height = "60px";
                });

            // Flashcard Custom Instructions
            new Setting(advancedContent)
                .setName("Flashcard Custom Instructions")
                .setDesc("Optional: extra rules for flashcards (e.g., multiple-choice format).")
                .addTextArea(text => {
                    text.setPlaceholder("E.g., create multiple-choice questions with 4 options...")
                        .setValue(this.options.envCustomInstructions || "")
                        .onChange(v => this.options.envCustomInstructions = v || "");
                    text.inputEl.style.width = "100%";
                    text.inputEl.style.height = "60px";
                });

            // Generate button
            new Setting(container).addButton(b => b
                .setButtonText("üìö Create Learning Environment")
                .setCta()
                .onClick(() => {
                    this.plugin.generateLearningEnvironment(this.options);
                    this.close();
                })
            );
            return;
        }

        // Standard tabs (Flashcards / Summary)
        const sliderSetting = new Setting(container)
            .setName("Detail Level")
            .setDesc("1 = Brief ‚Üí 5 = Exhaustive");

        const sliderContainer = sliderSetting.controlEl.createDiv({ cls: "slider-container" });
        sliderContainer.style.display = "flex";
        sliderContainer.style.alignItems = "center";

        const levelLabel = sliderContainer.createEl("span", {
            text: this.getLevelLabel(this.options.detailLevel),
            cls: "level-label"
        });
        levelLabel.style.marginRight = "10px";
        levelLabel.style.fontWeight = "bold";
        levelLabel.style.minWidth = "100px";

        const slider = sliderContainer.createEl("input", {
            type: "range",
            attr: { min: "1", max: "5", step: "1" }
        });
        slider.value = this.options.detailLevel;
        slider.style.width = "120px";
        slider.addEventListener("input", (e) => {
            this.options.detailLevel = e.target.value;
            levelLabel.textContent = this.getLevelLabel(e.target.value);
        });

        // Shared: Save Location
        new Setting(container)
            .setName("Save Location")
            .addDropdown(d => d
                .addOption("inline", "Inline")
                .addOption("folder", "Folder")
                .setValue(this.options.saveLocation)
                .onChange(v => this.options.saveLocation = v)
            );

        // Tab-specific options
        if (this.activeTab === 'flashcards') {
            new Setting(container)
                .setName("Card Style")
                .addDropdown(d => d
                    .addOption("single", "Single-line (::)")
                    .addOption("multi", "Multi-line (?)")
                    .setValue(this.options.cardStyle)
                    .onChange(v => this.options.cardStyle = v)
                );

            // Multiple Choice Toggle
            const fcMcContainer = container.createDiv({ cls: 'mc-options-container' });
            const fcChoiceCountSetting = new Setting(fcMcContainer)
                .setName("Number of Choices")
                .setDesc("How many answer options per question")
                .addDropdown(d => d
                    .addOption("2", "2")
                    .addOption("3", "3")
                    .addOption("4", "4")
                    .addOption("5", "5")
                    .setValue(this.options.choiceCount)
                    .onChange(v => this.options.choiceCount = v)
                );
            fcChoiceCountSetting.settingEl.style.display = this.options.multipleChoice ? 'flex' : 'none';

            new Setting(container)
                .setName("üîò Multiple Choice")
                .setDesc("Generate questions with A/B/C/D answer options")
                .addToggle(toggle => {
                    toggle.setValue(this.options.multipleChoice);
                    toggle.onChange(v => {
                        this.options.multipleChoice = v;
                        fcChoiceCountSetting.settingEl.style.display = v ? 'flex' : 'none';
                    });
                });
            container.appendChild(fcMcContainer);

            new Setting(container)
                .setName("Quantity Override")
                .setDesc("Leave 'Auto' or set specific number")
                .addText(t => t
                    .setPlaceholder("Auto")
                    .setValue(this.options.cardCount)
                    .onChange(v => this.options.cardCount = v || "Auto")
                );

            // Advanced Options for Flashcards
            const fcAdvancedContainer = container.createDiv({ cls: 'advanced-options-container' });
            const fcAdvancedContent = fcAdvancedContainer.createDiv({ cls: 'advanced-content' });
            fcAdvancedContent.style.display = 'none';
            fcAdvancedContent.style.marginTop = '8px';
            fcAdvancedContent.style.paddingLeft = '12px';
            fcAdvancedContent.style.borderLeft = '2px solid var(--interactive-accent)';

            new Setting(fcAdvancedContainer)
                .setName("‚öôÔ∏è Advanced Options")
                .setDesc("Custom instructions for flashcard generation")
                .addToggle(toggle => {
                    toggle.setValue(false);
                    toggle.onChange(v => {
                        fcAdvancedContent.style.display = v ? 'block' : 'none';
                    });
                });

            fcAdvancedContainer.appendChild(fcAdvancedContent);

            new Setting(fcAdvancedContent)
                .setName("Flashcard Custom Instructions")
                .setDesc("Optional: extra rules for flashcards (e.g., multiple-choice format).")
                .addTextArea(text => {
                    text.setPlaceholder("E.g., create multiple-choice questions with 4 options...")
                        .setValue(this.options.flashcardCustomInstructions || "")
                        .onChange(v => this.options.flashcardCustomInstructions = v || "");
                    text.inputEl.style.width = "100%";
                    text.inputEl.style.height = "60px";
                });
        }

        // Advanced Options for Summary tab
        if (this.activeTab === 'summary') {
            const sumAdvancedContainer = container.createDiv({ cls: 'advanced-options-container' });
            const sumAdvancedContent = sumAdvancedContainer.createDiv({ cls: 'advanced-content' });
            sumAdvancedContent.style.display = 'none';
            sumAdvancedContent.style.marginTop = '8px';
            sumAdvancedContent.style.paddingLeft = '12px';
            sumAdvancedContent.style.borderLeft = '2px solid var(--interactive-accent)';

            new Setting(sumAdvancedContainer)
                .setName("‚öôÔ∏è Advanced Options")
                .setDesc("Custom instructions for summary generation")
                .addToggle(toggle => {
                    toggle.setValue(false);
                    toggle.onChange(v => {
                        sumAdvancedContent.style.display = v ? 'block' : 'none';
                    });
                });

            sumAdvancedContainer.appendChild(sumAdvancedContent);

            new Setting(sumAdvancedContent)
                .setName("Summary Custom Instructions")
                .setDesc("Optional: extra rules for summary generation.")
                .addTextArea(text => {
                    text.setPlaceholder("E.g., focus on formulas, ignore examples...")
                        .setValue(this.options.summaryCustomInstructions || "")
                        .onChange(v => this.options.summaryCustomInstructions = v || "");
                    text.inputEl.style.width = "100%";
                    text.inputEl.style.height = "60px";
                });
        }

        // Generate button
        new Setting(container).addButton(b => b
            .setButtonText(this.activeTab === 'flashcards' ? "üé¥ Generate Flashcards" : "üìù Generate Summary")
            .setCta()
            .onClick(() => {
                if (this.activeTab === 'flashcards') {
                    this.plugin.generateFlashcards(this.options);
                } else {
                    this.plugin.generateSummary(this.options);
                }
                this.close();
            })
        );
    }

    getLevelLabel(level) {
        const labels = {
            "1": "1 - Brief",
            "2": "2 - Basic",
            "3": "3 - Standard",
            "4": "4 - Detailed",
            "5": "5 - Exhaustive"
        };
        return labels[level] || "3 - Standard";
    }

    onClose() { this.contentEl.empty(); }
}

// ==================== SETTINGS TAB WITH TABS ====================
class AILearningSettingTab extends PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
        this.activeTab = 'general';
    }

    display() {
        const { containerEl } = this;
        containerEl.empty();

        containerEl.createEl('h2', { text: 'üß† AI Learning Assistant' });

        // Tab bar
        const tabBar = containerEl.createDiv({ cls: "settings-tab-bar" });
        tabBar.style.display = "flex";
        tabBar.style.gap = "0";
        tabBar.style.marginBottom = "16px";
        tabBar.style.borderBottom = "2px solid var(--background-modifier-border)";

        const tabs = [
            { id: 'general', label: '‚öôÔ∏è General' },
            { id: 'flashcards', label: 'üé¥ Flashcard Prompts' },
            { id: 'summary', label: 'üìù Summary Prompts' }
        ];

        const tabButtons = {};
        tabs.forEach(tab => {
            const btn = tabBar.createEl("button", { text: tab.label });
            btn.style.padding = "8px 16px";
            btn.style.border = "none";
            btn.style.background = "transparent";
            btn.style.cursor = "pointer";
            btn.style.fontSize = "14px";
            btn.style.borderBottom = "2px solid transparent";
            btn.style.marginBottom = "-2px";
            tabButtons[tab.id] = btn;

            btn.onclick = () => {
                this.activeTab = tab.id;
                this.updateTabStyles(tabButtons);
                this.renderTabContent(contentDiv);
            };
        });

        const contentDiv = containerEl.createDiv({ cls: "settings-tab-content" });
        contentDiv.style.marginTop = "16px";

        this.updateTabStyles(tabButtons);
        this.renderTabContent(contentDiv);
    }

    updateTabStyles(tabButtons) {
        Object.entries(tabButtons).forEach(([id, btn]) => {
            btn.style.borderBottomColor = id === this.activeTab ? 'var(--interactive-accent)' : 'transparent';
            btn.style.color = id === this.activeTab ? 'var(--interactive-accent)' : '';
        });
    }

    renderTabContent(container) {
        container.empty();

        switch (this.activeTab) {
            case 'general':
                this.renderGeneralTab(container);
                break;
            case 'flashcards':
                this.renderPromptsTab(container, 'flashcardPrompts', 'Flashcard', DEFAULT_FLASHCARD_PROMPTS);
                break;
            case 'summary':
                this.renderPromptsTab(container, 'summaryPrompts', 'Summary', DEFAULT_SUMMARY_PROMPTS);
                break;
        }
    }

    renderGeneralTab(container) {
        const provider = this.plugin.getProvider();

        if (provider) {
            // === PROVIDER MODE ===
            container.createEl('h3', { text: 'üîå OpenRouter Provider' });

            const balanceEl = container.createDiv({ cls: 'setting-item-description', style: 'margin-bottom: 10px; font-weight: bold; color: var(--text-accent);' });
            balanceEl.setText("Checking balance...");
            this.plugin.fetchCredits().then(credit => {
                balanceEl.setText(credit ? `üí≥ Balance: $${credit}` : "üí≥ Balance: Unknown");
            });

            new Setting(container)
                .setName('Configure API Key')
                .setDesc('Open the OpenRouter Provider settings to manage your API key.')
                .addButton(b => b
                    .setButtonText('Open Provider Settings')
                    .onClick(() => {
                        this.app.setting.open();
                        this.app.setting.openTabById('openrouter-provider');
                    }));

            container.createEl('h3', { text: 'ü§ñ Model' });

            new Setting(container)
                .setName('Default Model')
                .setDesc(`Current: ${this.plugin.settings.model}`)
                .addButton(b => b
                    .setButtonText("Select Model")
                    .onClick(() => {
                        provider.openModelSelector('ai-flashcards', () => {
                            this.plugin.settings.model = provider.getModel('ai-flashcards');
                            this.plugin.saveSettings();
                            this.display();
                        });
                    }));

        } else {
            // === STANDALONE MODE ===
            container.createEl('h3', { text: 'üîå API Configuration (Standalone)' });

            const warning = container.createDiv({ cls: 'setting-item-description' });
            warning.style.color = 'var(--text-error)';
            warning.style.fontWeight = 'bold';
            warning.style.marginBottom = '15px';
            warning.innerHTML = "‚ö†Ô∏è Works best with <b>OpenRouter Provider</b> plugin.<br>You are currently in standalone mode.";

            new Setting(container)
                .setName('OpenRouter API Key')
                .setDesc('Enter your OpenRouter API key here.')
                .addText(t => t
                    .setPlaceholder('sk-or-...')
                    .setValue(this.plugin.settings.apiKey)
                    .onChange(async v => {
                        this.plugin.settings.apiKey = v;
                        await this.plugin.saveSettings();
                    }));

            new Setting(container)
                .setName('Model ID')
                .setDesc('Manually enter the model ID (e.g., google/gemini-2.0-flash-exp:free)')
                .addText(t => t
                    .setPlaceholder('provider/model-name')
                    .setValue(this.plugin.settings.model)
                    .onChange(async v => {
                        this.plugin.settings.model = v;
                        await this.plugin.saveSettings();
                    }));
        }

        new Setting(container)
            .setName('Target Language')
            .addText(t => t
                .setValue(this.plugin.settings.language)
                .onChange(async v => { this.plugin.settings.language = v; await this.plugin.saveSettings(); }));

        // Defaults
        container.createEl('h3', { text: '‚öôÔ∏è Defaults' });

        new Setting(container)
            .setName('Default Detail Level')
            .addDropdown(d => d
                .addOption("1", "1 - Brief")
                .addOption("2", "2 - Basic")
                .addOption("3", "3 - Standard")
                .addOption("4", "4 - Detailed")
                .addOption("5", "5 - Exhaustive")
                .setValue(this.plugin.settings.defaultDetailLevel)
                .onChange(async v => { this.plugin.settings.defaultDetailLevel = v; await this.plugin.saveSettings(); }));

        new Setting(container)
            .setName('Default Card Style')
            .addDropdown(d => d
                .addOption("single", "Single-line (::)")
                .addOption("multi", "Multi-line (?)")
                .setValue(this.plugin.settings.cardStyle)
                .onChange(async v => { this.plugin.settings.cardStyle = v; await this.plugin.saveSettings(); }));

        new Setting(container)
            .setName('Default Save Location')
            .addDropdown(d => d
                .addOption("inline", "Inline")
                .addOption("folder", "Folder")
                .setValue(this.plugin.settings.saveLocation)
                .onChange(async v => { this.plugin.settings.saveLocation = v; await this.plugin.saveSettings(); }));

        new Setting(container)
            .setName('Global Custom Instructions')
            .setDesc('Applied to all AI requests')
            .addTextArea(text => {
                text.setPlaceholder('Extra rules for all prompts...')
                    .setValue(this.plugin.settings.customInstructions)
                    .onChange(async v => { this.plugin.settings.customInstructions = v; await this.plugin.saveSettings(); });
                text.inputEl.style.width = "100%";
                text.inputEl.style.height = "80px";
            });
    }

    renderPromptsTab(container, settingKey, label, defaults) {
        container.createEl('h3', { text: `${label} Prompt Customization` });
        container.createEl('p', {
            text: 'Customize what the AI is told at each detail level.',
            cls: 'setting-item-description'
        });

        for (let level = 1; level <= 5; level++) {
            const key = String(level);
            const prompts = this.plugin.settings[settingKey]?.[key] || defaults[key];
            const levelNames = ["", "Brief", "Basic", "Standard", "Detailed", "Exhaustive"];

            const levelHeader = container.createDiv();
            levelHeader.style.marginTop = "16px";
            levelHeader.style.marginBottom = "8px";
            levelHeader.style.fontWeight = "bold";
            levelHeader.style.fontSize = "14px";
            levelHeader.textContent = `Level ${level}: ${levelNames[level]}`;

            new Setting(container)
                .setName('Goal')
                .setDesc('What the AI should accomplish')
                .addTextArea(text => {
                    text.setValue(prompts.purpose)
                        .onChange(async v => {
                            if (!this.plugin.settings[settingKey]) {
                                this.plugin.settings[settingKey] = JSON.parse(JSON.stringify(defaults));
                            }
                            if (!this.plugin.settings[settingKey][key]) {
                                this.plugin.settings[settingKey][key] = { ...defaults[key] };
                            }
                            this.plugin.settings[settingKey][key].purpose = v;
                            await this.plugin.saveSettings();
                        });
                    text.inputEl.style.width = "100%";
                    text.inputEl.style.height = "40px";
                });

            new Setting(container)
                .setName('Detail Guidance')
                .setDesc('How thoroughly to process content')
                .addTextArea(text => {
                    text.setValue(prompts.detail)
                        .onChange(async v => {
                            if (!this.plugin.settings[settingKey]) {
                                this.plugin.settings[settingKey] = JSON.parse(JSON.stringify(defaults));
                            }
                            if (!this.plugin.settings[settingKey][key]) {
                                this.plugin.settings[settingKey][key] = { ...defaults[key] };
                            }
                            this.plugin.settings[settingKey][key].detail = v;
                            await this.plugin.saveSettings();
                        });
                    text.inputEl.style.width = "100%";
                    text.inputEl.style.height = "40px";
                });
        }

        // Reset button
        new Setting(container)
            .addButton(btn => btn
                .setButtonText(`Reset ${label} Prompts to Defaults`)
                .setWarning()
                .onClick(async () => {
                    this.plugin.settings[settingKey] = JSON.parse(JSON.stringify(defaults));
                    await this.plugin.saveSettings();
                    new Notice(`‚úÖ ${label} prompts reset`);
                    this.renderTabContent(container.parentElement.querySelector('.settings-tab-content') || container);
                }));
    }
}
